#define LEFT_MOTOR OUT_A
#define RIGHT_MOTOR OUT_C
#define BOTH_MOTOR OUT_AC

#define FORWARD_SPEED_RIGHT 80
#define FORWARD_SPEED_LEFT 80
#define REVERSE_SPEED -60

#define LEFT_SENSOR IN_1
#define RIGHT_SENSOR IN_4
#define CROSS_SENSOR IN_2
#define TOP_SENSOR IN_1
#define LIGHT_LIMIT 48
#define CROSS_LIMIT 35

bool isTurning = false;
mutex moveMutex;
mutex crossMutex;

task senseLeft()
{

 while(true)
 {

  until(!isTurning && (Sensor(LEFT_SENSOR) < LIGHT_LIMIT));  // left sensor is over line
  Float(LEFT_MOTOR);                                 // turn right
  until(Sensor(LEFT_SENSOR) > LIGHT_LIMIT);
  Wait(5);
  OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);


 }
}

task senseRight()
{
 while(true)
 {

  until(!isTurning && (Sensor(RIGHT_SENSOR) < LIGHT_LIMIT));  // left sensor is over line
  Float(RIGHT_MOTOR);                               // turn left
  until(Sensor(RIGHT_SENSOR) > LIGHT_LIMIT);
  Wait(5);
  OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);

 }
}




task move()
{

 int moveList[200] = {1, 2, 3,2,3,2,1};
 int index = 0;
 while(index<ArrayLen(moveList))
 {
   Acquire(moveMutex);
   until(Sensor(CROSS_SENSOR) < CROSS_LIMIT);                  // robot at intersection
   isTurning = true;

   switch(moveList[index])
   {
    case(1):
    {
     Wait(100);
     Release(moveMutex);
     break;
    }
    case(2): //turn left
    {
     until(Sensor(RIGHT_SENSOR)< LIGHT_LIMIT &  Sensor(LEFT_SENSOR)< LIGHT_LIMIT);
    // until(Sensor(RIGHT_SENSOR)> LIGHT_LIMIT &  Sensor(LEFT_SENSOR)> LIGHT_LIMIT);
     Wait(90);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, -FORWARD_SPEED_LEFT);
     until(Sensor(CROSS_SENSOR)<CROSS_LIMIT);
     until(Sensor(CROSS_SENSOR)>CROSS_LIMIT);
     until(Sensor(LEFT_SENSOR)>CROSS_LIMIT);
     until(Sensor(RIGHT_SENSOR)>CROSS_LIMIT);
     Wait(55);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     Release(moveMutex);
     break;
    }

    case(3): //turn righ
    {
     until(Sensor(RIGHT_SENSOR)< LIGHT_LIMIT &  Sensor(LEFT_SENSOR)< LIGHT_LIMIT);
   //  until(Sensor(RIGHT_SENSOR)> LIGHT_LIMIT &  Sensor(LEFT_SENSOR)> LIGHT_LIMIT);
     Wait(90);
     OnFwd(RIGHT_MOTOR, -FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     until(Sensor(CROSS_SENSOR)<CROSS_LIMIT);
     until(Sensor(CROSS_SENSOR)>CROSS_LIMIT);
     Wait(55);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     Release(moveMutex);
     break;
    }
    case(4):
    {
     // turn around
     break;
    }

    default:
     // ?
  }
  ++index;
  isTurning = false;

 }
 while(true) //when there aren't anymore moves the robot stops
            Float(BOTH_MOTOR);
}

task main()
{
 SetSensorLight(LEFT_SENSOR);
 SetSensorLight(RIGHT_SENSOR);
 SetSensorLight(CROSS_SENSOR);
 OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
 OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
 Precedes(senseLeft, senseRight,move);

}


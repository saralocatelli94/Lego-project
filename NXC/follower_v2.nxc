#define LEFT_MOTOR OUT_A
#define RIGHT_MOTOR OUT_C
#define BOTH_MOTOR OUT_AC

// Hey, this is Adrian
// I will add a few comments here, and also in the move() task
// Instead of moving all sensors over the intersection after detecting with the CROSS sensor
// we could stop and turn immediately and use the RIGHT sensor to detect the next line to follow
// OR we could turn in place, instead of turning like how we did before
// the senseLeft() and senseRight() tasks assume that all motors are already running
// so the move task should turn them back on at the end

// It is maybe possible that tasks will try to control the motors simultenously
// this could be investigated

#define FORWARD_SPEED_RIGHT 58
#define FORWARD_SPEED_LEFT 60
#define REVERSE_SPEED -60

#define LEFT_SENSOR IN_1
#define RIGHT_SENSOR IN_4
#define CROSS_SENSOR IN_2
#define TOP_SENSOR IN_1
#define LIGHT_LIMIT 48
#define CROSS_LIMIT 35

bool isTurning = false;
mutex moveMutex;

task senseLeft()
{

 while(true)
 {

  until(!isTurning && (Sensor(LEFT_SENSOR) < LIGHT_LIMIT));  // left sensor is over line
  //Acquire(moveMutex);
  Float(LEFT_MOTOR);                                 // turn right
  //Release(moveMutex);
  until(Sensor(LEFT_SENSOR) > LIGHT_LIMIT);
  Wait(5); // ???
  //Acquire(moveMutex);
  OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
  //Release(moveMutex);
 }
}

task senseRight()
{
 while(true)
 {
  until(!isTurning && (Sensor(RIGHT_SENSOR) < LIGHT_LIMIT));  // left sensor is over line
  //Acquire(moveMutex);
  Float(RIGHT_MOTOR);                               // turn left
  //Release(moveMutex);
  until(Sensor(RIGHT_SENSOR) > LIGHT_LIMIT);
  Wait(5); // ???
  //Acquire(moveMutex);
  OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
  //Release(moveMutex);
 }
}

task move()
{

 // TODO: this is not the proper way to allocate an array in NXC because it gives an error
 // I think there is a solution in the NXC guide somewhere 
 //int moveList[200] = {1, 1, 1, 1, 1, 1, 1};         // list of moves: [forward, left, right, back]
 //int index = 0;
 while(true)
 {
  until(Sensor(CROSS_SENSOR) < CROSS_LIMIT);                  // robot at intersection
  PlayToneEx(350,500,8, FALSE);
  isTurning = true;

   //switch(moveList[index])
   switch(2)
   {
    case(1):
    {
     // go forward
    break;
    }
    case(2):
    {
     Wait(200);  // This wait could be taken out, and the RIGHT sensor moved over the black lines 
     // by adjusting the Waits to ignore detections until the next line to follow comes
     // we could also try counting the sensor detections, and stop when over the next line
     Float(BOTH_MOTOR);
     Wait(1000);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     // it is also possible to turn in place with the OnRev function I think
     // OnRev(LEFT_MOTOR, ???);
     until(Sensor(LEFT_SENSOR) < LIGHT_LIMIT);  // left sensor is over line
     Wait(250);
     // the senseLeft() and senseRight() tasks assume that all motors are already running
     // so the move task should turn them back on at the end
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     break;
    }
    case(3):
    {
     // turn right
     break;
    }
    case(4):
    {
     // turn around
     break;
    }

    default:
     // ?
  }
  //++index;
  isTurning = false;

 }
}

task main()
{
 SetSensorLight(LEFT_SENSOR);
 SetSensorLight(RIGHT_SENSOR);
 SetSensorLight(CROSS_SENSOR);
 OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
 OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);

 /* while(true){
    printf("light level L%d", Sensor(LEFT_SENSOR));
 }     */

 Precedes(senseLeft, senseRight,move);

}


#define LEFT_MOTOR OUT_A
#define RIGHT_MOTOR OUT_C
#define BOTH_MOTOR OUT_AC

// I will add a few comments here, and also in the move() task
// Instead of moving all sensors over the intersection after detecting with the CROSS sensor
// we could stop and turn immediately and use the RIGHT sensor to detect the next line to follow
// OR we could turn in place, instead of turning like how we did before
// the senseLeft() and senseRight() tasks assume that all motors are already running
// so the move task should turn them back on at the end

// It is maybe possible that tasks will try to control the motors simultenously
// this could be investigated

#define FORWARD_SPEED_RIGHT 91 // 58
#define FORWARD_SPEED_LEFT 91 // 60
#define TURN_SPEED_RIGHT 71
#define TURN_SPEED_LEFT 73
#define REVERSE_SPEED_LEFT -71
#define REVERSE_SPEED_RIGHT -68

#define LEFT_SENSOR IN_1
#define RIGHT_SENSOR IN_4
#define CROSS_SENSOR IN_2
#define TOP_SENSOR IN_1
#define LIGHT_LIMIT 48
#define CROSS_LIMIT 36    //35

bool isTurning = false;
bool wasReversed = false;
bool wasReversed2 = false;
mutex moveMutex;

task senseLeft()
{
 while(true)
 {
   until(!isTurning && (Sensor(LEFT_SENSOR) < LIGHT_LIMIT));  // left sensor is over line

   Acquire(moveMutex);
   if(!wasReversed2)
   {
     Float(LEFT_MOTOR);                                 // turn right
     //Release(moveMutex);
     until(Sensor(LEFT_SENSOR) > LIGHT_LIMIT);
     //Wait(20); // ???
     //Acquire(moveMutex);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
   }
   else
   {
     //PlayToneEx(350,500,8, FALSE);
     OnFwd(LEFT_MOTOR, -(REVERSE_SPEED_LEFT));
     Wait(60);
     OnFwd(LEFT_MOTOR, REVERSE_SPEED_LEFT);
     isTurning = true;
   }
   Release(moveMutex);
 }
}

task senseRight()
{
 while(true)
 {
   until(!isTurning && (Sensor(RIGHT_SENSOR) < LIGHT_LIMIT));  // left sensor is over line
   Acquire(moveMutex);
   if(!wasReversed2)
   {
     Float(RIGHT_MOTOR);                               // turn left
     //Release(moveMutex);
     until(Sensor(RIGHT_SENSOR) > LIGHT_LIMIT);
     //Wait(20); // ???
     //Acquire(moveMutex);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
   }
   else
   {
     //PlayToneEx(350,500,8, FALSE);
     OnFwd(RIGHT_MOTOR, -(REVERSE_SPEED_RIGHT));
     Wait(60);
     OnFwd(RIGHT_MOTOR, REVERSE_SPEED_RIGHT);
     isTurning = true;
   }
   Release(moveMutex);
 }
}

/*task waitReverse()
{
  printf("OOOOOO", Sensor(LEFT_SENSOR));
  Wait(600);
  wasReversed2 = false;
  printf("XXXXXX", Sensor(LEFT_SENSOR));

}*/

task move()
{

 // TODO: this is not the proper way to allocate an array in NXC because it gives an error
 // I think there is a solution in the NXC guide somewhere 

 //int moveList[200] = {4,1,1,2,1,2,1,5,4,3,1,3,1,3,1,1,5,3,2,1,5,2,1,5,2,3,3,1,5,3,2,3,1,1,5,3,1,3,2,1,5,3,2,2,1,1};         // list of moves: [forward, left, right, back]
 //int moveList[200] = {5,2,5,1,3,5,4,5};
 int moveList[200] = {1,1,5,4,1,3,1,3,1,3,1,1,5,3,2,1,2,1,1,1,2,3,1,2,1,1,2,1,2,1,1,5,3,1,1,1,5,3,1,2,1,2,1,2,1,1,1,1,5,4,1,1,2,1,2,1,1,2,1,5,3,1,1,1,5,3,2,2,1,1,5,2,3,2,1,2,1,5,3,1,5,2,1,3,1,1,3,1,3,1,1,1,5,3,2,1,1,1,5,2,3,3,1,5,4,2,3,2,1,2,1,5,3,1,1,3,1,2,2,1,5,3,2,2,1,1,1,1,5,3,2,1,1,1,5,2,3,1,3,1,3,1,5,3,1,5,3,2,2,1,5,3,1,5,3,2,2,1,5,2,3,1,1,2,1,5,3,2,1,3,1,3,1,5,2,3,3,1,1,1,5,3,2,1,1,1,1};
 int index = 0;
 while(true)
 {
  until(Sensor(CROSS_SENSOR) < CROSS_LIMIT);                  // robot at intersection
  Acquire(moveMutex);
  //PlayToneEx(350,500,8, FALSE);
  isTurning = true;
  if(wasReversed)
  {
    if(moveList[index] == 4)
    {
    }
    else
    {
      Float(BOTH_MOTOR);
      Wait(100);
      OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
      OnFwd(LEFT_MOTOR,FORWARD_SPEED_LEFT);
      Wait(160);  // 300
    }
    start senseLeft;
    start senseRight;
    wasReversed = false;
  }

   switch(moveList[index])
   {
    case(1):
    {
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     //PlayToneEx(350,500,8, FALSE);
     until(Sensor(CROSS_SENSOR) > CROSS_LIMIT);
     Wait(10);
     Release(moveMutex);
     isTurning = false;
     break;
    }
    case(2): //turn left
    {
     Float(BOTH_MOTOR);
     OnFwd(RIGHT_MOTOR, TURN_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, TURN_SPEED_LEFT);
     until(Sensor(RIGHT_SENSOR)< LIGHT_LIMIT &  Sensor(LEFT_SENSOR)< LIGHT_LIMIT);
     Wait(100);

     OnFwd(RIGHT_MOTOR, TURN_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, -TURN_SPEED_LEFT);
     until(Sensor(CROSS_SENSOR)<CROSS_LIMIT);
     until(Sensor(LEFT_SENSOR)>LIGHT_LIMIT && Sensor(RIGHT_SENSOR)>LIGHT_LIMIT);
     Wait(45);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     Release(moveMutex);
     isTurning = false;
     break;
    }

    case(3):
    {
      OnFwd(RIGHT_MOTOR, TURN_SPEED_RIGHT);
      OnFwd(LEFT_MOTOR, TURN_SPEED_LEFT);
      until(Sensor(RIGHT_SENSOR)< LIGHT_LIMIT &&  Sensor(LEFT_SENSOR)< LIGHT_LIMIT);
      Wait(110);
      OnFwd(RIGHT_MOTOR, -TURN_SPEED_RIGHT);
      OnFwd(LEFT_MOTOR, TURN_SPEED_LEFT);
      until(Sensor(CROSS_SENSOR)<CROSS_LIMIT);
      until(Sensor(RIGHT_SENSOR)<LIGHT_LIMIT);
      until(Sensor(LEFT_SENSOR)>LIGHT_LIMIT && Sensor(RIGHT_SENSOR)>LIGHT_LIMIT);
      Wait(55);
      OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
      OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     Release(moveMutex);
     isTurning = false;
     break;
    }
    case(4):
    {
     // turn around
	   /*OnFwd(BOTH_MOTOR, 0);
	   OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
	   OnFwd(LEFT_MOTOR, REVERSE_SPEED_LEFT);;
     until(Sensor(LEFT_SENSOR) < LIGHT_LIMIT);  // left sensor is over line
	   PlayToneEx(350,500,8, FALSE);
	   OnFwd(BOTH_MOTOR, 0);
	   OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
	   Wait( 90);  //100
     until(Sensor(LEFT_SENSOR) > LIGHT_LIMIT);
     Wait(5); // ???
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);*/
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     until(Sensor(RIGHT_SENSOR)< LIGHT_LIMIT &&  Sensor(LEFT_SENSOR)< LIGHT_LIMIT);
     Wait(70);
     OnFwd(RIGHT_MOTOR, 80);
     OnFwd(LEFT_MOTOR, -80);
     until(Sensor(CROSS_SENSOR)<CROSS_LIMIT);
     until(Sensor(CROSS_SENSOR)>CROSS_LIMIT);
     Wait(150);
     OnFwd(RIGHT_MOTOR, 60);
     OnFwd(LEFT_MOTOR, -60);
     /*until(Sensor(CROSS_SENSOR)<CROSS_LIMIT);
     //Wait(30);
     until(Sensor(LEFT_SENSOR)<LIGHT_LIMIT);
     until(Sensor(LEFT_SENSOR)>LIGHT_LIMIT);

     //until(Sensor(LEFT_SENSOR)>LIGHT_LIMIT);
     isTurning = false;
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);*/
     until(Sensor(CROSS_SENSOR)<CROSS_LIMIT); // -------
     OnFwd(RIGHT_MOTOR, 41);
     OnFwd(LEFT_MOTOR, -43);
     until(Sensor(LEFT_SENSOR)<LIGHT_LIMIT);
     until(Sensor(LEFT_SENSOR)>LIGHT_LIMIT && Sensor(RIGHT_SENSOR)>LIGHT_LIMIT);
     Wait(50);
     isTurning = false;
     OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
     OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);  // -----
     Release(moveMutex);
     break;
    }
    case(5):
    {
     // backwards
     //PlayToneEx(350,500,8, FALSE);
     Float(BOTH_MOTOR);
     //Wait(10);
     OnFwd(BOTH_MOTOR, 0);
     Wait(100);
     OnFwd(LEFT_MOTOR, REVERSE_SPEED_LEFT);
     OnFwd(RIGHT_MOTOR, REVERSE_SPEED_RIGHT);
     Release(moveMutex);
     wasReversed = true;
     wasReversed2 = true;
     Wait(200);
     //PlayToneEx(350,500,8, FALSE);
     isTurning = false; // no isTurning = false;
     Wait(700);
     wasReversed2 = false;
     stop senseLeft;
     stop senseRight;
     PlayToneEx(350,200,7, FALSE);
     PlayToneEx(415,200,7, FALSE);
     break;
    }
    default:
     // ?
  }
  ++index;
  /*if(index == 8)
  {
    index = 0;
  }*/
 }
}

task main()
{
 SetSensorLight(LEFT_SENSOR);
 SetSensorLight(RIGHT_SENSOR);
 SetSensorLight(CROSS_SENSOR);
 OnFwd(LEFT_MOTOR, FORWARD_SPEED_LEFT);
 OnFwd(RIGHT_MOTOR, FORWARD_SPEED_RIGHT);

 /* while(true){
    printf("light level L%d", Sensor(LEFT_SENSOR));
 }     */

 Precedes(senseLeft, senseRight,move);

}


